{"ast":null,"code":"var r = function (r) {\n    return function (r) {\n      return !!r && \"object\" == typeof r;\n    }(r) && !function (r) {\n      var t = Object.prototype.toString.call(r);\n      return \"[object RegExp]\" === t || \"[object Date]\" === t || function (r) {\n        return r.$$typeof === e;\n      }(r);\n    }(r);\n  },\n  e = \"function\" == typeof Symbol && Symbol.for ? Symbol.for(\"react.element\") : 60103;\nfunction t(r, e) {\n  return !1 !== e.clone && e.isMergeableObject(r) ? u(Array.isArray(r) ? [] : {}, r, e) : r;\n}\nfunction n(r, e, n) {\n  return r.concat(e).map(function (r) {\n    return t(r, n);\n  });\n}\nfunction o(r) {\n  return Object.keys(r).concat(function (r) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(r).filter(function (e) {\n      return r.propertyIsEnumerable(e);\n    }) : [];\n  }(r));\n}\nfunction c(r, e) {\n  try {\n    return e in r;\n  } catch (r) {\n    return !1;\n  }\n}\nfunction u(e, i, a) {\n  (a = a || {}).arrayMerge = a.arrayMerge || n, a.isMergeableObject = a.isMergeableObject || r, a.cloneUnlessOtherwiseSpecified = t;\n  var f = Array.isArray(i);\n  return f === Array.isArray(e) ? f ? a.arrayMerge(e, i, a) : function (r, e, n) {\n    var i = {};\n    return n.isMergeableObject(r) && o(r).forEach(function (e) {\n      i[e] = t(r[e], n);\n    }), o(e).forEach(function (o) {\n      (function (r, e) {\n        return c(r, e) && !(Object.hasOwnProperty.call(r, e) && Object.propertyIsEnumerable.call(r, e));\n      })(r, o) || (i[o] = c(r, o) && n.isMergeableObject(e[o]) ? function (r, e) {\n        if (!e.customMerge) return u;\n        var t = e.customMerge(r);\n        return \"function\" == typeof t ? t : u;\n      }(o, n)(r[o], e[o], n) : t(e[o], n));\n    }), i;\n  }(e, i, a) : t(i, a);\n}\nu.all = function (r, e) {\n  if (!Array.isArray(r)) throw new Error(\"first argument should be an array\");\n  return r.reduce(function (r, t) {\n    return u(r, t, e);\n  }, {});\n};\nvar i = u;\nfunction a(r) {\n  var e = (r = r || {}).storage || window && window.localStorage,\n    t = r.key || \"vuex\";\n  function n(r, e) {\n    var t = e.getItem(r);\n    try {\n      return \"string\" == typeof t ? JSON.parse(t) : \"object\" == typeof t ? t : void 0;\n    } catch (r) {}\n  }\n  function o() {\n    return !0;\n  }\n  function c(r, e, t) {\n    return t.setItem(r, JSON.stringify(e));\n  }\n  function u(r, e) {\n    return Array.isArray(e) ? e.reduce(function (e, t) {\n      return function (r, e, t, n) {\n        return !/^(__proto__|constructor|prototype)$/.test(e) && ((e = e.split ? e.split(\".\") : e.slice(0)).slice(0, -1).reduce(function (r, e) {\n          return r[e] = r[e] || {};\n        }, r)[e.pop()] = t), r;\n      }(e, t, (n = r, void 0 === (n = ((o = t).split ? o.split(\".\") : o).reduce(function (r, e) {\n        return r && r[e];\n      }, n)) ? void 0 : n));\n      var n, o;\n    }, {}) : r;\n  }\n  function a(r) {\n    return function (e) {\n      return r.subscribe(e);\n    };\n  }\n  (r.assertStorage || function () {\n    e.setItem(\"@@\", 1), e.removeItem(\"@@\");\n  })(e);\n  var f,\n    s = function () {\n      return (r.getState || n)(t, e);\n    };\n  return r.fetchBeforeUse && (f = s()), function (n) {\n    r.fetchBeforeUse || (f = s()), \"object\" == typeof f && null !== f && (n.replaceState(r.overwrite ? f : i(n.state, f, {\n      arrayMerge: r.arrayMerger || function (r, e) {\n        return e;\n      },\n      clone: !1\n    })), (r.rehydrated || function () {})(n)), (r.subscriber || a)(n)(function (n, i) {\n      (r.filter || o)(n) && (r.setState || c)(t, (r.reducer || u)(i, r.paths), e);\n    });\n  };\n}\nexport default a;","map":{"version":3,"mappings":"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","names":["isMergeableObject","value","isNonNullObject","stringValue","Object","prototype","toString","call","$$typeof","REACT_ELEMENT_TYPE","isReactElement","isSpecial","Symbol","for","cloneUnlessOtherwiseSpecified","options","clone","deepmerge","Array","isArray","defaultArrayMerge","target","source","concat","map","element","getKeys","keys","getOwnPropertySymbols","filter","symbol","propertyIsEnumerable","getEnumerableOwnPropertySymbols","propertyIsOnObject","object","property","_","arrayMerge","sourceIsArray","destination","forEach","key","hasOwnProperty","customMerge","getMergeFunction","mergeObject","all","array","Error","reduce","prev","next","storage","window","localStorage","getState","getItem","JSON","parse","undefined","err","setState","state","setItem","stringify","reducer","paths","substate","path","t","r","e","n","test","split","slice","pop","shvl","subscriber","store","handler","subscribe","assertStorage","removeItem","savedState","fetchSavedState","fetchBeforeUse","replaceState","overwrite","merge","arrayMerger","saved","rehydrated","mutation"],"sources":["../node_modules/deepmerge/dist/cjs.js","../src/index.ts","../node_modules/shvl/dist/shvl.mjs"],"sourcesContent":["'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","import { Store, MutationPayload } from \"vuex\";\nimport merge from \"deepmerge\";\nimport * as shvl from \"shvl\";\n\ninterface Storage {\n  getItem: (key: string) => any;\n  setItem: (key: string, value: any) => void;\n  removeItem: (key: string) => void;\n}\n\ninterface Options<State> {\n  key?: string;\n  paths?: string[];\n  reducer?: (state: State, paths: string[]) => object;\n  subscriber?: (\n    store: Store<State>\n    ) => (handler: (mutation: any, state: State) => void) => void;\n  storage?: Storage;\n  getState?: (key: string, storage: Storage) => any;\n  setState?: (key: string, state: any, storage: Storage) => void;\n  filter?: (mutation: MutationPayload) => boolean;\n  arrayMerger?: (state: any[], saved: any[]) => any;\n  rehydrated?: (store: Store<State>) => void;\n  fetchBeforeUse?: boolean;\n  overwrite?: boolean;\n  assertStorage?: (storage: Storage) => void | Error;\n}\n\nexport default function <State>(\n  options?: Options<State>\n): (store: Store<State>) => void {\n  options = options || {};\n\n  const storage = options.storage || (window && window.localStorage);\n  const key = options.key || \"vuex\";\n\n  function getState(key, storage) {\n    const value = storage.getItem(key);\n\n    try {\n      return (typeof value === \"string\")\n        ? JSON.parse(value) : (typeof value === \"object\")\n        ? value : undefined;\n    } catch (err) {}\n\n    return undefined;\n  }\n\n  function filter() {\n    return true;\n  }\n\n  function setState(key, state, storage) {\n    return storage.setItem(key, JSON.stringify(state));\n  }\n\n  function reducer(state, paths) {\n    return Array.isArray(paths)\n      ? paths.reduce(function (substate, path) {\n          return shvl.set(substate, path, shvl.get(state, path));\n        }, {})\n      : state;\n  }\n\n  function subscriber(store) {\n    return function (handler) {\n      return store.subscribe(handler);\n    };\n  }\n\n  const assertStorage =\n    options.assertStorage ||\n    (() => {\n      storage.setItem(\"@@\", 1);\n      storage.removeItem(\"@@\");\n    });\n\n  assertStorage(storage);\n\n  const fetchSavedState = () => (options.getState || getState)(key, storage);\n\n  let savedState;\n\n  if (options.fetchBeforeUse) {\n    savedState = fetchSavedState();\n  }\n\n  return function (store: Store<State>) {\n    if (!options.fetchBeforeUse) {\n      savedState = fetchSavedState();\n    }\n\n    if (typeof savedState === \"object\" && savedState !== null) {\n      store.replaceState(\n        options.overwrite\n          ? savedState\n          : merge(store.state, savedState, {\n              arrayMerge:\n                options.arrayMerger ||\n                function (store, saved) {\n                  return saved;\n                },\n              clone: false,\n            })\n      );\n      (options.rehydrated || function () {})(store);\n    }\n\n    (options.subscriber || subscriber)(store)(function (mutation, state) {\n      if ((options.filter || filter)(mutation)) {\n        (options.setState || setState)(\n          key,\n          (options.reducer || reducer)(state, options.paths),\n          storage\n        );\n      }\n    });\n  };\n}\n","function t(t,r,e){return void 0===(t=(r.split?r.split(\".\"):r).reduce(function(t,r){return t&&t[r]},t))?e:t}function r(t,r,e,n){return!/^(__proto__|constructor|prototype)$/.test(r)&&((r=r.split?r.split(\".\"):r.slice(0)).slice(0,-1).reduce(function(t,r){return t[r]=t[r]||{}},t)[r.pop()]=e),t}export{t as get,r as set};\n//# sourceMappingURL=shvl.mjs.map\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}